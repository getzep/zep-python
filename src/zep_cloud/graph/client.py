# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.apidata_clone_graph_response import ApidataCloneGraphResponse
from ..types.apidata_edge_type import ApidataEdgeType
from ..types.apidata_entity_type import ApidataEntityType
from ..types.apidata_entity_type_response import ApidataEntityTypeResponse
from ..types.apidata_episode_data import ApidataEpisodeData
from ..types.apidata_fact_rating_instruction import ApidataFactRatingInstruction
from ..types.apidata_graph import ApidataGraph
from ..types.apidata_graph_episode import ApidataGraphEpisode
from ..types.apidata_graph_search_results import ApidataGraphSearchResults
from ..types.apidata_success_response import ApidataSuccessResponse
from ..types.graphiti_add_triple_response import GraphitiAddTripleResponse
from ..types.graphiti_graph_search_scope import GraphitiGraphSearchScope
from ..types.graphiti_reranker import GraphitiReranker
from ..types.graphiti_search_filters import GraphitiSearchFilters
from ..types.models_graph_data_type import ModelsGraphDataType
from .edge.client import AsyncEdgeClient, EdgeClient
from .episode.client import AsyncEpisodeClient, EpisodeClient
from .node.client import AsyncNodeClient, NodeClient
from .raw_client import AsyncRawGraphClient, RawGraphClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class GraphClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawGraphClient(client_wrapper=client_wrapper)
        self.edge = EdgeClient(client_wrapper=client_wrapper)

        self.episode = EpisodeClient(client_wrapper=client_wrapper)

        self.node = NodeClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawGraphClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawGraphClient
        """
        return self._raw_client

    def list_entity_types(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ApidataEntityTypeResponse:
        """
        Returns all entity types for a project.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataEntityTypeResponse
            The list of entity types.

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.list_entity_types()
        """
        _response = self._raw_client.list_entity_types(request_options=request_options)
        return _response.data

    def set_entity_types_internal(
        self,
        *,
        edge_types: typing.Optional[typing.Sequence[ApidataEdgeType]] = OMIT,
        entity_types: typing.Optional[typing.Sequence[ApidataEntityType]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataSuccessResponse:
        """
        Sets the entity types for a project, replacing any existing ones.

        Parameters
        ----------
        edge_types : typing.Optional[typing.Sequence[ApidataEdgeType]]

        entity_types : typing.Optional[typing.Sequence[ApidataEntityType]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataSuccessResponse
            Entity types set successfully

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.set_entity_types_internal()
        """
        _response = self._raw_client.set_entity_types_internal(
            edge_types=edge_types, entity_types=entity_types, request_options=request_options
        )
        return _response.data

    def add(
        self,
        *,
        data: str,
        type: ModelsGraphDataType,
        created_at: typing.Optional[str] = OMIT,
        graph_id: typing.Optional[str] = OMIT,
        source_description: typing.Optional[str] = OMIT,
        user_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataGraphEpisode:
        """
        Add data to the graph.

        Parameters
        ----------
        data : str

        type : ModelsGraphDataType

        created_at : typing.Optional[str]

        graph_id : typing.Optional[str]
            graph_id is the ID of the graph to which the data will be added. If adding to the user graph, please use user_id field instead.

        source_description : typing.Optional[str]

        user_id : typing.Optional[str]
            User ID is the ID of the user to which the data will be added. If not adding to a user graph, please use graph_id field instead.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataGraphEpisode
            Added episode

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.add(
            data="data",
            type="text",
        )
        """
        _response = self._raw_client.add(
            data=data,
            type=type,
            created_at=created_at,
            graph_id=graph_id,
            source_description=source_description,
            user_id=user_id,
            request_options=request_options,
        )
        return _response.data

    def add_batch(
        self,
        *,
        episodes: typing.Sequence[ApidataEpisodeData],
        graph_id: typing.Optional[str] = OMIT,
        user_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ApidataGraphEpisode]:
        """
        Add data to the graph in batch mode, processing episodes concurrently. Use only for data that is insensitive to processing order.

        Parameters
        ----------
        episodes : typing.Sequence[ApidataEpisodeData]

        graph_id : typing.Optional[str]
            graph_id is the ID of the graph to which the data will be added. If adding to the user graph, please use user_id field instead.

        user_id : typing.Optional[str]
            User ID is the ID of the user to which the data will be added. If not adding to a user graph, please use graph_id field instead.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ApidataGraphEpisode]
            Added episodes

        Examples
        --------
        from zep_cloud import ApidataEpisodeData, Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.add_batch(
            episodes=[
                ApidataEpisodeData(
                    data="data",
                    type="text",
                )
            ],
        )
        """
        _response = self._raw_client.add_batch(
            episodes=episodes, graph_id=graph_id, user_id=user_id, request_options=request_options
        )
        return _response.data

    def add_fact_triple(
        self,
        *,
        fact: str,
        fact_name: str,
        target_node_name: str,
        created_at: typing.Optional[str] = OMIT,
        expired_at: typing.Optional[str] = OMIT,
        fact_uuid: typing.Optional[str] = OMIT,
        graph_id: typing.Optional[str] = OMIT,
        invalid_at: typing.Optional[str] = OMIT,
        source_node_name: typing.Optional[str] = OMIT,
        source_node_summary: typing.Optional[str] = OMIT,
        source_node_uuid: typing.Optional[str] = OMIT,
        target_node_summary: typing.Optional[str] = OMIT,
        target_node_uuid: typing.Optional[str] = OMIT,
        user_id: typing.Optional[str] = OMIT,
        valid_at: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GraphitiAddTripleResponse:
        """
        Add a fact triple for a user or group

        Parameters
        ----------
        fact : str
            The fact relating the two nodes that this edge represents

        fact_name : str
            The name of the edge to add. Should be all caps using snake case (eg RELATES_TO)

        target_node_name : str
            The name of the target node to add

        created_at : typing.Optional[str]
            The timestamp of the message

        expired_at : typing.Optional[str]
            The time (if any) at which the edge expires

        fact_uuid : typing.Optional[str]
            The uuid of the edge to add

        graph_id : typing.Optional[str]

        invalid_at : typing.Optional[str]
            The time (if any) at which the fact stops being true

        source_node_name : typing.Optional[str]
            The name of the source node to add

        source_node_summary : typing.Optional[str]
            The summary of the source node to add

        source_node_uuid : typing.Optional[str]
            The source node uuid

        target_node_summary : typing.Optional[str]
            The summary of the target node to add

        target_node_uuid : typing.Optional[str]
            The target node uuid

        user_id : typing.Optional[str]

        valid_at : typing.Optional[str]
            The time at which the fact becomes true

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GraphitiAddTripleResponse
            Resulting triple

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.add_fact_triple(
            fact="fact",
            fact_name="fact_name",
            target_node_name="target_node_name",
        )
        """
        _response = self._raw_client.add_fact_triple(
            fact=fact,
            fact_name=fact_name,
            target_node_name=target_node_name,
            created_at=created_at,
            expired_at=expired_at,
            fact_uuid=fact_uuid,
            graph_id=graph_id,
            invalid_at=invalid_at,
            source_node_name=source_node_name,
            source_node_summary=source_node_summary,
            source_node_uuid=source_node_uuid,
            target_node_summary=target_node_summary,
            target_node_uuid=target_node_uuid,
            user_id=user_id,
            valid_at=valid_at,
            request_options=request_options,
        )
        return _response.data

    def clone(
        self,
        *,
        source_graph_id: typing.Optional[str] = OMIT,
        source_user_id: typing.Optional[str] = OMIT,
        target_graph_id: typing.Optional[str] = OMIT,
        target_user_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataCloneGraphResponse:
        """
        Clone a user or group graph.

        Parameters
        ----------
        source_graph_id : typing.Optional[str]
            source_graph_id is the ID of the graph to be cloned. Required if source_user_id is not provided

        source_user_id : typing.Optional[str]
            user_id of the user whose graph is being cloned. Required if source_graph_id is not provided

        target_graph_id : typing.Optional[str]
            target_graph_id is the ID to be set on the cloned graph. Must not point to an existing graph. Required if target_user_id is not provided.

        target_user_id : typing.Optional[str]
            user_id to be set on the cloned user. Must not point to an existing user. Required if target_graph_id is not provided.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataCloneGraphResponse
            Response object containing group_id or user_id pointing to the new graph

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.clone()
        """
        _response = self._raw_client.clone(
            source_graph_id=source_graph_id,
            source_user_id=source_user_id,
            target_graph_id=target_graph_id,
            target_user_id=target_user_id,
            request_options=request_options,
        )
        return _response.data

    def search(
        self,
        *,
        query: str,
        bfs_origin_node_uuids: typing.Optional[typing.Sequence[str]] = OMIT,
        center_node_uuid: typing.Optional[str] = OMIT,
        graph_id: typing.Optional[str] = OMIT,
        limit: typing.Optional[int] = OMIT,
        min_fact_rating: typing.Optional[float] = OMIT,
        min_score: typing.Optional[float] = OMIT,
        mmr_lambda: typing.Optional[float] = OMIT,
        reranker: typing.Optional[GraphitiReranker] = OMIT,
        scope: typing.Optional[GraphitiGraphSearchScope] = OMIT,
        search_filters: typing.Optional[GraphitiSearchFilters] = OMIT,
        user_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataGraphSearchResults:
        """
        Perform a graph search query.

        Parameters
        ----------
        query : str
            The string to search for (required)

        bfs_origin_node_uuids : typing.Optional[typing.Sequence[str]]
            Nodes that are the origins of the BFS searches

        center_node_uuid : typing.Optional[str]
            Node to rerank around for node distance reranking

        graph_id : typing.Optional[str]
            The graph_id to search in. When searching user graph, please use user_id instead.

        limit : typing.Optional[int]
            The maximum number of facts to retrieve. Defaults to 10. Limited to 50.

        min_fact_rating : typing.Optional[float]
            The minimum rating by which to filter relevant facts

        min_score : typing.Optional[float]
            Deprecated

        mmr_lambda : typing.Optional[float]
            weighting for maximal marginal relevance

        reranker : typing.Optional[GraphitiReranker]
            Defaults to RRF

        scope : typing.Optional[GraphitiGraphSearchScope]
            Defaults to Edges. Communities will be added in the future.

        search_filters : typing.Optional[GraphitiSearchFilters]
            Search filters to apply to the search

        user_id : typing.Optional[str]
            The user_id when searching user graph. If not searching user graph, please use graph_id instead.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataGraphSearchResults
            Graph search results

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.search(
            query="query",
        )
        """
        _response = self._raw_client.search(
            query=query,
            bfs_origin_node_uuids=bfs_origin_node_uuids,
            center_node_uuid=center_node_uuid,
            graph_id=graph_id,
            limit=limit,
            min_fact_rating=min_fact_rating,
            min_score=min_score,
            mmr_lambda=mmr_lambda,
            reranker=reranker,
            scope=scope,
            search_filters=search_filters,
            user_id=user_id,
            request_options=request_options,
        )
        return _response.data

    def create(
        self,
        *,
        graph_id: str,
        description: typing.Optional[str] = OMIT,
        fact_rating_instruction: typing.Optional[ApidataFactRatingInstruction] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataGraph:
        """
        Creates a new graph.

        Parameters
        ----------
        graph_id : str

        description : typing.Optional[str]

        fact_rating_instruction : typing.Optional[ApidataFactRatingInstruction]

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataGraph
            The added graph

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.create(
            graph_id="graph_id",
        )
        """
        _response = self._raw_client.create(
            graph_id=graph_id,
            description=description,
            fact_rating_instruction=fact_rating_instruction,
            name=name,
            request_options=request_options,
        )
        return _response.data

    def get(self, graph_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> ApidataGraph:
        """
        Returns a graph.

        Parameters
        ----------
        graph_id : str
            The graph_id of the graph to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataGraph
            The graph that was retrieved.

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.get(
            graph_id="graphId",
        )
        """
        _response = self._raw_client.get(graph_id, request_options=request_options)
        return _response.data

    def delete(
        self, graph_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ApidataSuccessResponse:
        """
        Deletes a graph. If you would like to delete a user graph, make sure to use user.delete instead.

        Parameters
        ----------
        graph_id : str
            Graph ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataSuccessResponse
            Deleted

        Examples
        --------
        from zep_cloud import Zep

        client = Zep(
            api_key="YOUR_API_KEY",
        )
        client.graph.delete(
            graph_id="graphId",
        )
        """
        _response = self._raw_client.delete(graph_id, request_options=request_options)
        return _response.data


class AsyncGraphClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawGraphClient(client_wrapper=client_wrapper)
        self.edge = AsyncEdgeClient(client_wrapper=client_wrapper)

        self.episode = AsyncEpisodeClient(client_wrapper=client_wrapper)

        self.node = AsyncNodeClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawGraphClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawGraphClient
        """
        return self._raw_client

    async def list_entity_types(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ApidataEntityTypeResponse:
        """
        Returns all entity types for a project.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataEntityTypeResponse
            The list of entity types.

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.list_entity_types()


        asyncio.run(main())
        """
        _response = await self._raw_client.list_entity_types(request_options=request_options)
        return _response.data

    async def set_entity_types_internal(
        self,
        *,
        edge_types: typing.Optional[typing.Sequence[ApidataEdgeType]] = OMIT,
        entity_types: typing.Optional[typing.Sequence[ApidataEntityType]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataSuccessResponse:
        """
        Sets the entity types for a project, replacing any existing ones.

        Parameters
        ----------
        edge_types : typing.Optional[typing.Sequence[ApidataEdgeType]]

        entity_types : typing.Optional[typing.Sequence[ApidataEntityType]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataSuccessResponse
            Entity types set successfully

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.set_entity_types_internal()


        asyncio.run(main())
        """
        _response = await self._raw_client.set_entity_types_internal(
            edge_types=edge_types, entity_types=entity_types, request_options=request_options
        )
        return _response.data

    async def add(
        self,
        *,
        data: str,
        type: ModelsGraphDataType,
        created_at: typing.Optional[str] = OMIT,
        graph_id: typing.Optional[str] = OMIT,
        source_description: typing.Optional[str] = OMIT,
        user_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataGraphEpisode:
        """
        Add data to the graph.

        Parameters
        ----------
        data : str

        type : ModelsGraphDataType

        created_at : typing.Optional[str]

        graph_id : typing.Optional[str]
            graph_id is the ID of the graph to which the data will be added. If adding to the user graph, please use user_id field instead.

        source_description : typing.Optional[str]

        user_id : typing.Optional[str]
            User ID is the ID of the user to which the data will be added. If not adding to a user graph, please use graph_id field instead.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataGraphEpisode
            Added episode

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.add(
                data="data",
                type="text",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.add(
            data=data,
            type=type,
            created_at=created_at,
            graph_id=graph_id,
            source_description=source_description,
            user_id=user_id,
            request_options=request_options,
        )
        return _response.data

    async def add_batch(
        self,
        *,
        episodes: typing.Sequence[ApidataEpisodeData],
        graph_id: typing.Optional[str] = OMIT,
        user_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ApidataGraphEpisode]:
        """
        Add data to the graph in batch mode, processing episodes concurrently. Use only for data that is insensitive to processing order.

        Parameters
        ----------
        episodes : typing.Sequence[ApidataEpisodeData]

        graph_id : typing.Optional[str]
            graph_id is the ID of the graph to which the data will be added. If adding to the user graph, please use user_id field instead.

        user_id : typing.Optional[str]
            User ID is the ID of the user to which the data will be added. If not adding to a user graph, please use graph_id field instead.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ApidataGraphEpisode]
            Added episodes

        Examples
        --------
        import asyncio

        from zep_cloud import ApidataEpisodeData, AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.add_batch(
                episodes=[
                    ApidataEpisodeData(
                        data="data",
                        type="text",
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.add_batch(
            episodes=episodes, graph_id=graph_id, user_id=user_id, request_options=request_options
        )
        return _response.data

    async def add_fact_triple(
        self,
        *,
        fact: str,
        fact_name: str,
        target_node_name: str,
        created_at: typing.Optional[str] = OMIT,
        expired_at: typing.Optional[str] = OMIT,
        fact_uuid: typing.Optional[str] = OMIT,
        graph_id: typing.Optional[str] = OMIT,
        invalid_at: typing.Optional[str] = OMIT,
        source_node_name: typing.Optional[str] = OMIT,
        source_node_summary: typing.Optional[str] = OMIT,
        source_node_uuid: typing.Optional[str] = OMIT,
        target_node_summary: typing.Optional[str] = OMIT,
        target_node_uuid: typing.Optional[str] = OMIT,
        user_id: typing.Optional[str] = OMIT,
        valid_at: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GraphitiAddTripleResponse:
        """
        Add a fact triple for a user or group

        Parameters
        ----------
        fact : str
            The fact relating the two nodes that this edge represents

        fact_name : str
            The name of the edge to add. Should be all caps using snake case (eg RELATES_TO)

        target_node_name : str
            The name of the target node to add

        created_at : typing.Optional[str]
            The timestamp of the message

        expired_at : typing.Optional[str]
            The time (if any) at which the edge expires

        fact_uuid : typing.Optional[str]
            The uuid of the edge to add

        graph_id : typing.Optional[str]

        invalid_at : typing.Optional[str]
            The time (if any) at which the fact stops being true

        source_node_name : typing.Optional[str]
            The name of the source node to add

        source_node_summary : typing.Optional[str]
            The summary of the source node to add

        source_node_uuid : typing.Optional[str]
            The source node uuid

        target_node_summary : typing.Optional[str]
            The summary of the target node to add

        target_node_uuid : typing.Optional[str]
            The target node uuid

        user_id : typing.Optional[str]

        valid_at : typing.Optional[str]
            The time at which the fact becomes true

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GraphitiAddTripleResponse
            Resulting triple

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.add_fact_triple(
                fact="fact",
                fact_name="fact_name",
                target_node_name="target_node_name",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.add_fact_triple(
            fact=fact,
            fact_name=fact_name,
            target_node_name=target_node_name,
            created_at=created_at,
            expired_at=expired_at,
            fact_uuid=fact_uuid,
            graph_id=graph_id,
            invalid_at=invalid_at,
            source_node_name=source_node_name,
            source_node_summary=source_node_summary,
            source_node_uuid=source_node_uuid,
            target_node_summary=target_node_summary,
            target_node_uuid=target_node_uuid,
            user_id=user_id,
            valid_at=valid_at,
            request_options=request_options,
        )
        return _response.data

    async def clone(
        self,
        *,
        source_graph_id: typing.Optional[str] = OMIT,
        source_user_id: typing.Optional[str] = OMIT,
        target_graph_id: typing.Optional[str] = OMIT,
        target_user_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataCloneGraphResponse:
        """
        Clone a user or group graph.

        Parameters
        ----------
        source_graph_id : typing.Optional[str]
            source_graph_id is the ID of the graph to be cloned. Required if source_user_id is not provided

        source_user_id : typing.Optional[str]
            user_id of the user whose graph is being cloned. Required if source_graph_id is not provided

        target_graph_id : typing.Optional[str]
            target_graph_id is the ID to be set on the cloned graph. Must not point to an existing graph. Required if target_user_id is not provided.

        target_user_id : typing.Optional[str]
            user_id to be set on the cloned user. Must not point to an existing user. Required if target_graph_id is not provided.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataCloneGraphResponse
            Response object containing group_id or user_id pointing to the new graph

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.clone()


        asyncio.run(main())
        """
        _response = await self._raw_client.clone(
            source_graph_id=source_graph_id,
            source_user_id=source_user_id,
            target_graph_id=target_graph_id,
            target_user_id=target_user_id,
            request_options=request_options,
        )
        return _response.data

    async def search(
        self,
        *,
        query: str,
        bfs_origin_node_uuids: typing.Optional[typing.Sequence[str]] = OMIT,
        center_node_uuid: typing.Optional[str] = OMIT,
        graph_id: typing.Optional[str] = OMIT,
        limit: typing.Optional[int] = OMIT,
        min_fact_rating: typing.Optional[float] = OMIT,
        min_score: typing.Optional[float] = OMIT,
        mmr_lambda: typing.Optional[float] = OMIT,
        reranker: typing.Optional[GraphitiReranker] = OMIT,
        scope: typing.Optional[GraphitiGraphSearchScope] = OMIT,
        search_filters: typing.Optional[GraphitiSearchFilters] = OMIT,
        user_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataGraphSearchResults:
        """
        Perform a graph search query.

        Parameters
        ----------
        query : str
            The string to search for (required)

        bfs_origin_node_uuids : typing.Optional[typing.Sequence[str]]
            Nodes that are the origins of the BFS searches

        center_node_uuid : typing.Optional[str]
            Node to rerank around for node distance reranking

        graph_id : typing.Optional[str]
            The graph_id to search in. When searching user graph, please use user_id instead.

        limit : typing.Optional[int]
            The maximum number of facts to retrieve. Defaults to 10. Limited to 50.

        min_fact_rating : typing.Optional[float]
            The minimum rating by which to filter relevant facts

        min_score : typing.Optional[float]
            Deprecated

        mmr_lambda : typing.Optional[float]
            weighting for maximal marginal relevance

        reranker : typing.Optional[GraphitiReranker]
            Defaults to RRF

        scope : typing.Optional[GraphitiGraphSearchScope]
            Defaults to Edges. Communities will be added in the future.

        search_filters : typing.Optional[GraphitiSearchFilters]
            Search filters to apply to the search

        user_id : typing.Optional[str]
            The user_id when searching user graph. If not searching user graph, please use graph_id instead.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataGraphSearchResults
            Graph search results

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.search(
                query="query",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.search(
            query=query,
            bfs_origin_node_uuids=bfs_origin_node_uuids,
            center_node_uuid=center_node_uuid,
            graph_id=graph_id,
            limit=limit,
            min_fact_rating=min_fact_rating,
            min_score=min_score,
            mmr_lambda=mmr_lambda,
            reranker=reranker,
            scope=scope,
            search_filters=search_filters,
            user_id=user_id,
            request_options=request_options,
        )
        return _response.data

    async def create(
        self,
        *,
        graph_id: str,
        description: typing.Optional[str] = OMIT,
        fact_rating_instruction: typing.Optional[ApidataFactRatingInstruction] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApidataGraph:
        """
        Creates a new graph.

        Parameters
        ----------
        graph_id : str

        description : typing.Optional[str]

        fact_rating_instruction : typing.Optional[ApidataFactRatingInstruction]

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataGraph
            The added graph

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.create(
                graph_id="graph_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create(
            graph_id=graph_id,
            description=description,
            fact_rating_instruction=fact_rating_instruction,
            name=name,
            request_options=request_options,
        )
        return _response.data

    async def get(self, graph_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> ApidataGraph:
        """
        Returns a graph.

        Parameters
        ----------
        graph_id : str
            The graph_id of the graph to get.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataGraph
            The graph that was retrieved.

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.get(
                graph_id="graphId",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get(graph_id, request_options=request_options)
        return _response.data

    async def delete(
        self, graph_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ApidataSuccessResponse:
        """
        Deletes a graph. If you would like to delete a user graph, make sure to use user.delete instead.

        Parameters
        ----------
        graph_id : str
            Graph ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApidataSuccessResponse
            Deleted

        Examples
        --------
        import asyncio

        from zep_cloud import AsyncZep

        client = AsyncZep(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.graph.delete(
                graph_id="graphId",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete(graph_id, request_options=request_options)
        return _response.data
